1) Array - An array is a collection of elements, all of the same data type, stored in contiguous memory locations and accessed by an index.

2) contiguous memory - “Contiguous memory” means that all elements of an array are stored next to each other in RAM, without any gaps in between.

3) Why Arrays Use Contiguous Memory?

Because of this continuous block:

The CPU can directly compute the address of any element:

Address
(𝐴[𝑖])=Base address+𝑖×size of one element

Address(A[i])=Base address+i×size of one element

This gives O(1) random access.

Cache performance improves — nearby elements are likely loaded into the CPU cache together (called spatial locality).

4) In algorithm analysis:

O(1) (read “Big O of 1”) means constant time.

It tells us that the operation takes the same amount of time, no matter how large the data structure is.


Example:

int arr[5] = {10, 20, 30, 40, 50};


Memory Layout (each cell is one integer):

Address → 1000   1004   1008   1012   1016
Element → 10     20     30     40     50
Index   → 0      1      2      3      4

Here:

Base address = address of the first element (arr[0])

Index i = position offset

Each element is at:

Address(arr[i]) = Base + (i × size_of_one_element)


Basic Operations:

a) Traversal = Visit each element one by one.
Time Complexity: O(n)

b) Insertion = Insert an element at a given position pos
Time Complexity: O(n) (worst case, when inserting at start)

why worst case: 

Suppose you want to insert 5 at index 0.

You can’t just “shift memory” to make space at the front — the array must remain contiguous.
So, what happens?

You have to move every existing element one position to the right.

c) Deletion = Remove an element by value or by index.
Time Complexity: O(n) (because elements shift left)

d) Searching = Find whether an element exists or its index.
Time Complexity: O(n)

Searching types - 
1) Linear Search 
2) Binary Search 

Linear Search - 

Linear Search (Sequential Search)
Concept / Idea

Check each element one by one until you find the target.

Works on both sorted and unsorted arrays.

Algorithm (High-Level)

Start from index 0.

Compare each element with the target.

If a match is found → return the index.

If end of array is reached without a match → return -1 (not found).

Binary Search -

Concept / Idea

Works only on sorted arrays.

Use the divide-and-conquer approach:

Check the middle element.

If middle == target → found.

If middle < target → search right half.

If middle > target → search left half.

Repeat until array is exhausted.


Sorted array:

A sorted array is an array in which the elements are arranged in a specific order — either ascending or descending.

Ascending Order: Each element is less than or equal to the next element.
Example: [10, 20, 30, 40, 50]

Descending Order: Each element is greater than or equal to the next element.
Example: [50, 40, 30, 20, 10]

Unsorted array:

An unsorted array has elements in no particular order.

Example: [30, 10, 50, 20, 40]

Key Property:

You cannot perform binary search directly; only linear search is guaranteed to work.

Types of Array:

1) One-Dimensional Array (1D Array)

Definition: A linear sequence of elements stored in contiguous memory.

Access: arr[i]

Example:

arr = [10, 20, 30, 40, 50]

Use Cases: Storing lists, sequences, prefix sums, sliding window problems.

Memory layout (contiguous):

Index:   0   1   2   3   4
Value:  10  20  30  40  50

2) Two-Dimensional Array (2D Array / Matrix)

Definition: Array of arrays; can be thought of as rows × columns.

Access: arr[i][j]

Example:

matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]


Memory Layout:

Row-major: All elements of row 0, then row 1, etc. (C/C++)

Column-major: All elements of column 0, then column 1, etc. (Fortran, MATLAB)

Use Cases: Grid problems, image processing, DP tables, graphs adjacency matrices.

3) Multi-Dimensional Array (>2D)

Definition: Array of arrays of arrays (3D, 4D…)

Access: arr[i][j][k]…

Example: 3D array for storing RGB images (height × width × 3 colors)

image = [[[255,0,0], [0,255,0]], [[0,0,255], [255,255,0]]]

Use Cases: Images, tensors in ML, 3D game coordinates.

4) Dynamic Array

Definition: Resizable array (unlike static arrays).

Examples: Python list, Java ArrayList, C++ vector.

How it works:

Starts with capacity n.

When full → create new array with double capacity and copy elements.

Allows amortized O(1) insertion at the end.

Use Cases: When array size is unknown or changes frequently.

5) Specialized Arrays -->

a) Jagged Array (Ragged Array)

Rows can have different lengths (non-rectangular 2D array)

Example:

jagged = [[1,2,3], [4,5], [6,7,8,9]]

Useful for variable-length records or triangular matrices.

b) Sparse Array

Mostly contains zero or default values

Stored efficiently using coordinate/value pairs (not all memory allocated)

Use Cases: Large matrices with few non-zero elements

c) Circular Array

Logical rotation of array using modular indexing: (i + k) % n

Used in circular queues, buffers.

d) Associative Array / Hash Table

Conceptually array with key → value mapping

Implemented using arrays + hashing internally

Examples: Python dict, Java HashMap